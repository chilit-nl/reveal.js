# Impossible in Java? Think Again!
<!-- .slide: data-auto-animate -->

--

# Impossible in Java? Think Again!
### *Unlocking Native power with Java FFI*
<!-- .slide: data-auto-animate -->

---

<div style="display: flex; gap: 50px">
    <img src="./profile.jpg" height="400" width="400" style="border: 5px solid; border-image-source: linear-gradient(-45deg, #FFC796 0%, #FF6B95 100%); border-image-slice: 1;" />
    <div style="display: flex; flex-direction: column; justify-content: center; text-align: left;">
        <div>
            Lennart ten Wolde<br /><br/>
            Software Engineer, CHILIT
        </div>
    </div>
</div>

---

## Java Foreign Function & Memory API

<!-- .slide: data-auto-animate -->

--

## Java Foreign Function & Memory API

<!-- .slide: data-auto-animate -->
<!-- .slide: class="fragmented-lists" -->
* Call foreign functions using with a C-compatible interface (upcalls)
* Create function callbacks in Java that can be passed to foreign functions (downcalls)
* Manage native memory outside of the Java heap

--

### Motivation

<!-- .slide: class="fragmented-lists" -->
* Historically, Java Native Interface (JNI) is used.
  * Java 1.1 era
  * Required writing and building "glue code" in C/C++
* More demand for native interoperability
  * Hardware-accelerated Cryptography, HPC, multimedia, AI/ML
  * Integrate with OS, drivers, networking

--

### JEP 454

*"Ultimately, Java developers should have a supported API that enables them to straightforwardly consume any native library deemed useful for a particular task, without the tedious glue and clunkiness of JNI"*

---

## JNI's shortcommings

--

```java[|7]
public class Main {

    public static void main(String[] args) {
        new Main().log("Hello, J-Spring");
    }

    private native void log(String message);
}
```

--

```err
Exception in thread "main" java.lang.UnsatisfiedLinkError: 'void Main.log(
java.lang.String)'
	at Main.log(Native Method)
	at Main.main(Main.java:4)
```

--

### Header file generation

```sh [22: 3-4]
  -g:{lines,vars,source}       Generate only some debugging info
  -g:none                      Generate no debugging info
  -h <directory>
        Specify where to place generated native header files
  --help, -help, -?            Print this help message
  --help-extra, -X             Print help on extra options
```

```sh
javac -h . src/Main.java
```
<!-- .element: class="fragment" -->

--

```cpp [|15-16]
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Main */

#ifndef _Included_Main
#define _Included_Main
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Main
 * Method:    log
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_Main_log
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

--

## The clunkiness of JNI

<!-- .slide: class="fragmented-lists" -->
* Define native methods in Java
* Generate C/C++ header definitions
* Implement C/C++ glue code that interacts with java objects
* Compile and distribute platform-specific glue code binaries
* Load the glue code binary and dependencies at runtime

---

## Java FFI API

<!-- .slide: class="fragmented-lists" -->
* A full programmatic interface for native interop
* Obtain a `Linker` for access to foreign functions on current platform
  * Find functions by symbol name native to the OS
  * Create method handles to call down to native code
  * Create callbacks to allow native code to call up to Java

--

```java [1|2-3|4-5|7-9]
Linker linker = Linker.nativeLinker();
SymbolLookup stdlib = linker.defaultLookup();
MemorySegment exitAddr = stdlib.findOrThrow("rand");
MethodHandle rand = linker.downcallHandle(exitAddr,
    FunctionDescriptor.of(ValueLayout.JAVA_INT));

System.out.println(
    rand.invoke() // Print random integer via C standard library
);
```

--

```sh
java -cp out/ --enable-native-access=ALL-UNNAMED Main
1804289383
```

--

### Integer division with quotient and remainder

```java[3|4-7|8-9|11|12-13|15-16]
Linker linker = Linker.nativeLinker();
SymbolLookup stdlib = linker.defaultLookup();
MemorySegment exitAddr = stdlib.findOrThrow("div");
StructLayout divt = MemoryLayout.structLayout(
    ValueLayout.JAVA_INT.withName("quot"),
    ValueLayout.JAVA_INT.withName("rem")
);
MethodHandle div = linker.downcallHandle(exitAddr,
    FunctionDescriptor.of(divt, JAVA_INT, JAVA_INT));

MemorySegment result = (MemorySegment) div.invoke(Arena.ofAuto(), 31, 10);
int quot = result.getAtIndex(JAVA_INT, 0);
int rem = result.getAtIndex(JAVA_INT, 1);

System.out.printf("31 / 10 = %d (remainder: %d)\n", quot, rem);
// Output: 31 / 10 = 3 (remainder: 1)
```

--

### Upcalls

```c [|2]
void qsort( void* ptr, size_t count, size_t size,
            int (*comp)(const void*, const void*) );
```

--

```java [1-3|8|9-10|12-19|13-14|15-17|18|21-22|23|25-27]
public static int sort(MemorySegment a, MemorySegment b) {
    return a.get(JAVA_INT, 0) - b.get(JAVA_INT, 0);
}

public static void main(String[] args) throws Throwable {
    Linker linker = Linker.nativeLinker();
    SymbolLookup stdlib = linker.defaultLookup();
    MemorySegment qsortAddr = stdlib.findOrThrow("qsort");
    MethodHandle qsort = linker.downcallHandle(qsortAddr,
        FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS));

    MemorySegment callback = linker.upcallStub(
        MethodHandles.lookup().findStatic(Main.class, "sort",
            MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class)),
        FunctionDescriptor.of(JAVA_INT, 
            ADDRESS.withTargetLayout(JAVA_INT), 
            ADDRESS.withTargetLayout(JAVA_INT)),
        Arena.ofAuto()
    );

    MemorySegment ints = Arena.ofAuto().allocateFrom(JAVA_INT,
        5, 1, 3, 2, 4);
    qsort.invoke(ints, 5L, JAVA_INT.byteSize(), callback);

    Arrays.stream(ints.toArray(JAVA_INT))
        .forEach(i -> System.out.printf("%d ", i));
    // Output: 1 2 3 4 5
}
```

---

## Native Memory

<!-- .slide: class="fragmented-lists" -->
* MemorySegment is a bounded pointer to VRAM
  * Static. Cannot be managed by Java Heap
* Can be allocated and managed by native code
* Can be allocated and managed in Java

Note:
- Memory Arenas/Scopes
- Auto scope
- Structs (memory in a shape with a specific structure)
- MemoryLayout / StructLayout

--

### Arena

<!-- .slide: class="fragmented-lists" -->
* `Arena.global()` creates permanent memory segments
* `Arena.ofAuto()` segments are destroyed by GC
* `Arena.ofConfined()` segments are destroyed when the arena is closed
* `Arena.ofShared()` is the same as confined, but thread-safe

--

```java [3-7|4|6]
int[] result;

try(Arena arena = Arena.ofConfined()) {
    MemorySegment ints = arena.allocateFrom(JAVA_INT, 5, 1, 3, 2, 4);
    qsort.invoke(ints, 5L, JAVA_INT.byteSize(), callback);
    result = ints.toArray(JAVA_INT);
}

Arrays.stream(ints.toArray(JAVA_INT))
        .forEach(i -> System.out.printf("%d ", i));
```

--

### Memory Layout

<!-- .slide: class="fragmented-lists" -->
* Values (ADDRESS, JAVA_INT, JAVA_DOUBLE)
* Sequences (`MemoryLayout.sequenceLayout(5, JAVA_INT)`)
* Structs (`MemoryLayout.structLayout(...)`)
* Unions (`MemoryLayout.unionLayout(...)`)

--

### Structs

```java []
MemoryLayout.structLayout(
    JAVA_INT.withName("length"),
    MemoryLayout.paddingLayout(4),
    ADDRESS.withName("chars")
);
```
<!-- .element: data-id="code-solution" -->
<!-- .slide: data-auto-animate -->

--

### Structs

```java []
MemoryLayout.structLayout(
    JAVA_INT.withName("length"),
    // MemoryLayout.paddingLayout(4),
    ADDRESS.withName("chars")
);
```
<!-- .element: data-id="code-solution" -->
<!-- .slide: data-auto-animate -->

---

## jextract
### Generating FFI bindings automatically

--

```sh
jextract -l :<shared library path> \
  --output <output directory> \
  -I <header file search path> \
  -t <target package> \
  <header file path>
```

--

### Generating python bindings
```sh
jextract -l :/lib/x86_64-linux-gnu/libpython3.12.so.1.0 \
  --output src/main/java \
  -I /usr/include/python3.12 \
  -t org.python \
  </usr/include/python3.12/Python.h>
```

--

```java [|1|11|7-10,13,14,19|15-17|18,20]
import static org.python.Python_h.*;

// ..
    
public static void main(String[] args) {
    String myString = "Hello world!";
    String script = """
                 string = "%s"
                 print(string, ': ', len(string), sep='')
                 """.formatted(myString).stripIndent();
    Py_Initialize();
    
    try (Arena arena = Arena.ofConfined()) {
        MemorySegment nativeString = arena.allocateFrom(script);
        PyRun_SimpleStringFlags(
            nativeString,
            NULL);
        Py_Finalize();
    }
    Py_Exit(0);
}
```

---

## CHILIT @ J-Spring 2025

### Spice, waffles, fun and games!

<img src="./wafels.png" height="300" style="float: left" />
<img src="./stand.png" height="300" style="float: right" />
